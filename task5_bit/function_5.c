#include "prototypes.h"

void binary_print(int number) // функция вывода числа в двоичном виде
{
    int index = 8 * sizeof(int) - 1;
    unsigned int mask = 1 << index;
    for (; index >= 0; index--, mask >>= 1)
    {
        print("Number %d in binary form: ")
        if (number & mask) printf("1"); else printf("0");
        if (index % 8 == 0) printf(" ");
    }
}
/* reverse8: функция, которая принимает 8-битное число (байт) и возвращает
   этот байт, "зеркально" перевёрнутый по битам, т.е. бит 0  бит 7, бит 1  бит 6 и т.д. */
int reverse8(int x)          // объявление функции, static — означает видимость только в этом файле
{
    int reverse8 = 0;                          // r будет хранить результат (сначала все биты равны 0)

    for (int i = 0; i < 8; ++i) {           // цикл по индексам битов i = 0..7
        /* 1 << i создаёт маску с единицей в позиции i:
           например для i=0 маска = 0000 0001, для i=3 маска = 0000 1000.*/
        if (x & (1 << i))         // побитовая операция AND: проверяем, стоит ли в x бит i
            /* Если бит i в x равен 1, то устанавливаем в r бит (7 - i):
               r |= (1 << (7 - i)) — побитовое OR добавляет этот бит в r. */
            r |= ((1 << (7 - i));  // ставим зеркальный бит в r
    }

    return r;                               // возвращаем получившийся зеркальный байт
}

/* find_and_print: основная функция — читает N и выводит первые N целых чисел
   (в порядке возрастания), у которых младший байт равен reverse8(второго байта). */
void find_and_print(void)
{
    int value = 0;                               // в будущем, меняющееся число, которое мы будем выводить
    int N = 10;                             // количество чисел, которое пользователь хочет получить
    int found = 0;                          // счётчик найденных подходящих чисел
    printf("Enter N (how many numbers to print, default 10): "); // просим пользователя ввести N

    /* scanf считывает беззнаковое число (%d) и записывает в &N.
       Если чтение не прошло (возврат != 1) или ввели 0 — используем значение по умолчанию 10. */
    if (scanf("%d", &N) != 1 || N == 0) {
        N = 10;                             // значение по умолчанию
    }

    /* Внешний цикл: hi — "старшая" 16-битная часть числа.
       Мы перебираем hi от 0 до 65535 (включительно). */
    for (int hi = 0; found < N && hi <= 65535; ++hi) {

        /* Внутренний цикл: b — второй (по порядку) байт числа (byte1).
           b перебирается от 0 до 255 (включительно). */
        for (int b = 0; found < N && b <= 255; ++b) {

            int byte1 = (uint8_t)b;     // приводим b к виду "байт" — это второй байт числа
            int byte0 = reverse8(byte1); // вычисляем требуемый младший байт как зеркальный образ byte1

            /* Собираем полное число value из трёх частей:
               - hi << 16: помещаем hi в старшие 16 бит числа;
               - b << 8: помещаем byte1 в биты 8..15;
               - byte0: младший байт (биты 0..7).
               Оператор << — это сдвиг влево, | — побитовое OR (объединение битов). */
            value = (hi << 16) | (b << 8) | byte0;
            void binary_print(value);

            ++found;                     // увеличиваем счётчик найденных чисел на 1
        }
    }
}
 
